stop("No files matching the specified conditions (starts_with: '", starts_with,
"', ends_with: '", ends_with, "') found in the folder.")
}
total_files <- length(files)
if(total_files > 1000) {
warning("Large number of files. This may take a while.")
}
all_data <- lapply(files, function(file) {
tryCatch(
read.delim(file, header = header,sep = sep, ...),
error = function(e) {
warning(paste("Error reading file:", file, "-", e$message))
return(NULL)
}
)
})
# Remove any NULL entries caused by errors
all_data <- Filter(Negate(is.null), all_data)
if (length(all_data) == 0) {
stop("No valid data frames could be read from the .txt files.")
}
# Combine all data frames into one
combined_data <- bind_rows(all_data)
return(combined_data)
}
#---- --- ---- --- ---- --- ---- --- ---- --- ---- --- ----#
squash <- function(lst) {
do.call(c, lapply(lst, function(x) if (is.list(x) && !is.data.frame(x)) squash(x) else list(x)))
}
#' Move entries within a list up one level
#' @noRd
flatten <- function(lst) {
nested <- is_nested(lst)
res <- c(lst[!nested], unlist(lst[nested], recursive = FALSE))
if (sum(nested)) Recall(res) else return(res)
}
#---- --- ---- --- ---- --- ---- --- ---- --- ---- --- ----#
#' Efficiently bind multiple `data.frame`s by row and column
#'
#' @param ... `data.frame`s to combine.
#'
#' Each argument can either be a `data.frame`, a `list` that could be a `data.frame`, or a `list` of `data.frame`s.
#'
#' When row-binding, columns are matched by name, and any missing columns will be filled with `NA`.
#'
#' When column-binding, rows are matched by position, so all `data.frame`s must have the same number of rows. To match
#' by value, not position, see [mutate_joins].
#' @param .id `character(1)`. `data.frame` identifier.
#'
#' When `.id` is supplied, a new column of identifiers is created to link each row to its original `data.frame`. The
#' labels are taken from the named arguments to `bind_rows()`. When a `list` of `data.frame`s is supplied, the labels
#' are taken from the names of the `list`. If no names are found a numeric sequence is used instead.
#' @return A `data.frame`.
bind_cols <- function(...) {
lsts <- list(...)
lsts <- squash(lsts)
lsts <- Filter(Negate(is.null), lsts)
if (length(lsts) == 0L) return(data.frame())
lapply(lsts, function(x) is_df_or_vector(x))
lsts <- do.call(cbind, lsts)
if (!is.data.frame(lsts)) lsts <- as.data.frame(lsts)
lsts
}
bind_rows <- function(..., .id = NULL) {
lsts <- list(...)
lsts <- flatten(lsts)
lsts <- Filter(Negate(is.null), lsts)
lapply(lsts, function(x) is_df_or_vector(x))
lapply(lsts, function(x) if (is.atomic(x) && !is_named(x)) stop("Vectors must be named."))
if (!missing(.id)) {
lsts <- lapply(seq_along(lsts), function(i) {
nms <- names(lsts)
id_df <- data.frame(id = if (is.null(nms)) as.character(i) else nms[i], stringsAsFactors = FALSE)
colnames(id_df) <- .id
cbind(id_df, lsts[[i]])
})
}
nms <- unique(unlist(lapply(lsts, names)))
lsts <- lapply(
lsts,
function(x) {
if (!is.data.frame(x)) x <- data.frame(as.list(x), stringsAsFactors = FALSE)
for (i in nms[!nms %in% names(x)]) x[[i]] <- NA
x
}
)
names(lsts) <- NULL
do.call(rbind, lsts)
}
# Code inspired by https://github.com/nathaneastwood/poorman/blob/master/R/glimpse.R
#' Take a Quick Overview of Your Data
#'
#' `peek()` provides a transposed view of your dataset: columns are displayed vertically, while the data for each column
#' is shown horizontally. This layout allows you to inspect all the columns of a `data.frame` at a glance. It serves as a
#' convenient wrapper around [utils::str()], with the added benefit of invisibly returning the input object, making it
#' suitable for use in data pipelines.
#'
#' @param x The object to be inspected.
#' @param width `integer(1)`. Specifies the maximum width of the output.
#' @param ... Additional arguments to pass to [utils::str()].
#'
#' @return
#' The input object `x`, returned invisibly.
#'
#' @examples
#' peek(mtcars)
#' @export
peek <- function(x, width = getOption("width"), ...) {
UseMethod("peek")
}
#' @export
peek.default <- function(x, ...) {
cat("<Default object of class ", class(x)[1], ">\n", sep = "")
invisible(x)
}
#' @export
peek.data.frame <- function(x, ...) {
# Get the number of rows and columns
n_rows <- nrow(x)
n_cols <- ncol(x)
# Display rows and columns
display_rows_and_columns(n_rows, n_cols)
# Calculate the maximum column name length
max_col_name_length <- find_colname_length(x)
# Display each column with dynamically calculated vector length
display_columns(x, max_col_name_length)
invisible(x)
}
# Function to display number of rows and columns
display_rows_and_columns <- function(n_rows, n_cols) {
cat("Rows:", n_rows, "\n")
cat("Columns:", n_cols, "\n")
cat("-------------------------\n")
}
# Function to display columns with name, class, and first few elements
display_columns <- function(x, max_col_name_length) {
# Create a mapping of class names to abbreviations
class_abbreviations <- get_class_abbreviations()
# Loop over columns and display each one
for (col_name in names(x)) {
# Get the first few values for each column
col_values <- head(x[[col_name]], get_display_length(x[[col_name]]))
col_class <- class(x[[col_name]])[1]
# Use abbreviation if available, otherwise keep the full class name
col_class_abbr <- class_abbreviations[[col_class]] %||% paste("<", col_class, ">")
# Convert factors to character for display
if (is.factor(x[[col_name]])) {
col_values <- as.character(col_values)
}
# Display the column with proper alignment
display_column(col_name, col_class_abbr, col_values, max_col_name_length)
}
}
# Function to get the appropriate number of
# elements to display for each vector
get_display_length <- function(x) {
# Default value for vec.len from options("str") (default is 4)
vec_len <- getOption("str")$vec.len %||% 4
# Adjust based on the type of vector
if (is.factor(x)) {
return(vec_len * 2)
} else if (is.numeric(x) || is.integer(x)) {
return(vec_len * 3)
} else {
return(vec_len * 2)
}
}
# Function to get class abbreviations for common types
get_class_abbreviations <- function() {
return(c(
"factor" = "<fct>",
"numeric" = "<dbl>",
"character" = "<chr>",
"integer" = "<int>",
"logical" = "<lgl>",
"Date" = "<date>",
"POSIXct" = "<ct>"
))
}
find_colname_length <- function(x) {
max_length<- max(nchar(names(x))) + 5
return(max_length)
}
# Function to display individual column with class in lighter color
display_column <- function(col_name, col_class_abbr, col_values, max_col_name_length) {
# ANSI escape code for light gray color
light_color <- "\033[38;5;145m"
reset_color <- "\033[39m"
# Ensure that the column names have values
col_name_length <- if (length(col_name) > 0) nchar(col_name) else 0
# Fallback if max column name length is invalid (e.g., empty column names)
max_col_name_length <- ifelse(is.finite(col_name_length), max(col_name_length, max_col_name_length), max_col_name_length)
# Format and print the column details with aligned output
cat(sprintf("$ %-*s %s%s%s %s...\n",
max_col_name_length, col_name,
light_color, col_class_abbr, reset_color,
paste(col_values, collapse = ", ")))
}
diabetes_mellitus <- merge_into_frame("Diabetes-Data",starts_with = "data-")
# Get size of content inside folder. Mainly used to check
# if git push will be successful or need to send to LFS
get_folder_size <- function(folder,
units = "Kb",
recursive = TRUE,
omit_folders = TRUE){
units <- match.arg(units, c("B","Kb","Mb","Gb"),
several.ok = FALSE)
root_dir <- getwd()
folder <- as.character(folder)
# Exclude 'renv' from project directory
dirs <- omit_folders(root_dir)
check_for_file <- is_file(name = folder,
dir = dirs)
if(check_for_file){
stop("You have entered a file name.
Please enter a project folder instead")
}
target_dirs <- grep(paste0("/", folder, "$"), dirs, value = TRUE)
if(length(target_dirs) == 0){
stop(paste0("'", folder, "' folder not found in the current directory or subdirectories"))
}
if (length(target_dirs) > 1) {
cat("Multiple '", folder, "' folders found:\n", sep = "")
for (i in seq_along(target_dirs)) {
cat(i, ": ", target_dirs[i], "\n", sep = "")
}
choice <- as.integer(readline(prompt = paste("Enter the number of the '", folder,
"' folder you want to use: ", sep = "")))
if (is.na(choice) || choice < 1 || choice > length(target_dirs)) {
stop("Invalid selection")
}
target_dir <- target_dirs[choice]
} else {
target_dir <- target_dirs[1]
}
files <- list.files(target_dir,
full.names = TRUE,
recursive = recursive)
total_files <- length(files)
if(total_files > 1000) {
warning("Large number of files. This may take a while.")
}
# Calculate total file size
file_sizes <- file.info(files)$size
total_size_bytes <- sum(file_sizes, na.rm = TRUE)
has_extensions <- sub(".*\\.([a-zA-Z0-9]+)$", "\\1",files)
no_paths_just_ext <- unique(
has_extensions[
grepl("\\.[a-zA-Z0-9]+$", files)
]
)
# Convert total size to the specified units
total_size <- switch(units,
B = total_size_bytes,
Kb = total_size_bytes / 1024,
Mb = total_size_bytes / (1024^2),
Gb = total_size_bytes / (1024^3))
# Return a list containing size, total files, and unique extensions
return(
data.frame(
folder = folder,
size = total_size,
files = total_files,
extensions = I(
list(no_paths_just_ext)
)
)
)
}
is_file <- function(name,
dir,
ignore_dot_folders = FALSE){
if(!is.character(name)){
name <- as.character(name)
}
if(ignore_dot_folders){
# Exclude renv from directories
dirs <- omit_folders(dir)
}
# Explicitly set 'recursive' to FALSE so function stops before
# exploring external directories
file_check <- list.files(dir,pattern = name, full.names = TRUE,
recursive = FALSE)
if(length(file_check) == 0){
stop("'",name," 'folder or file not found in the current project")
}
if(length(file_check) > 0 && !(file_check %in% dirs)){
TRUE
} else {
warning("'", name, "' is a folder, not a file.")
FALSE
}
}
##-------------------------------------------------------------------##
# Exclude renv folder from project directories to speed up path look up
omit_folders <- function(dir){
exclude_folders <- c("/renv",
"/.git",
"/.github",
"/.quarto",
"/.Rproj.user"
)
# Get all directories within the root, recursively
dirs <- list.dirs(dir, full.names = TRUE, recursive = TRUE)
# Remove any directory that matches one of the excluded folders
for (folder in exclude_folders) {
dirs <- dirs[!grepl(folder, dirs)]
}
return(dirs)
}
diabetes_mellitus <- merge_into_frame("Diabetes-Data",starts_with = "data-")
files <- list.files(target_dirs, full.names = TRUE)
root_dir <- getwd()
folder <- as.character(folder)
folder <- as.character("Diabetes-Data")
dirs <- omit_folders(root_dir)
target_dirs <- grep(paste0("/", folder, "$"), dirs, value = TRUE)
View(diabetes_mellitus)
files <- list.files(target_dirs, full.names = TRUE)
row_counts <- numeric(length(files))
for (i in seq_along(files)) {
row_counts[i] <- nrow(read.delim(files[i], header = FALSE))
}
file_row_counts <- data.frame(
file = basename(files), # Get only the file names, not full paths
rows = row_counts
)
print(file_row_counts)
View(diabetes_mellitus)
#---- --- ---- --- ---- --- ---- --- ----#
# Diabetes mellitus and treatment
diabetes_mellitus <- merge_into_frame("Diabetes-Data",starts_with = "data-") |>
rename(date = V1,
time = V2,
measurement = V3,
value = V4)
#---- --- ---- --- ---- --- ---- --- ----#
# Diabetes mellitus and treatment
diabetes_mellitus <- merge_into_frame("Diabetes-Data",starts_with = "data-") |>
dplyr::rename(date = V1,
time = V2,
measurement = V3,
value = V4)
peek(diabetes_mellitus)
#---- --- ---- --- ---- --- ---- --- ----#
# Diabetes mellitus and treatment
diabetes_mellitus <- merge_into_frame("Diabetes-Data",starts_with = "data-") |>
dplyr::rename(date = V1,
time = V2,
measurement = V3,
value = V4) |>
mutate(date = as.Date(date),
time = as.POSIXct(time, format = "%H:%M:%S"),
value = as.numeric(value))
#---- --- ---- --- ---- --- ---- --- ----#
# Diabetes mellitus and treatment
diabetes_mellitus <- merge_into_frame("Diabetes-Data",starts_with = "data-") |>
dplyr::rename(date = V1,
time = V2,
measurement = V3,
value = V4) |>
dplyr::mutate(date = as.Date(date),
time = as.POSIXct(time, format = "%H:%M:%S"),
value = as.numeric(value))
#---- --- ---- --- ---- --- ---- --- ----#
# Diabetes mellitus and treatment
diabetes_mellitus <- merge_into_frame("Diabetes-Data",starts_with = "data-") |>
dplyr::rename(date = V1,
time = V2,
measurement = V3,
value = V4) |>
dplyr::mutate(
time = as.POSIXct(time, format = "%H:%M:%S"),
value = as.numeric(value))
#---- --- ---- --- ---- --- ---- --- ----#
# Diabetes mellitus and treatment
diabetes_mellitus <- merge_into_frame("Diabetes-Data",starts_with = "data-") |>
dplyr::rename(date = V1,
time = V2,
measurement = V3,
value = V4) |>
dplyr::mutate(
time = as.POSIXct(time),
value = as.numeric(value))
#---- --- ---- --- ---- --- ---- --- ----#
# Diabetes mellitus and treatment
diabetes_mellitus <- merge_into_frame("Diabetes-Data",starts_with = "data-") |>
dplyr::rename(date = V1,
time = V2,
measurement = V3,
value = V4) |>
dplyr::mutate(value = as.numeric(value))
count_na(diabetes_mellitus)
diabetes_mellitus <- merge_into_frame("Diabetes-Data",starts_with = "data-")
count_na(diabetes_mellitus)
diabetes_mellitus <- merge_into_frame("Diabetes-Data",starts_with = "data-") |>
dplyr::rename(date = V1,
time = V2,
measurement = V3,
value = V4)
count_na(diabetes_mellitus)
diabetes_mellitus$value
unique(diabetes_mellitus$value)
as.double("086")
as.numeric("086")
as.numeric("1.25")
as.numeric(unique(diabetes_mellitus$value))
sum(is.na((as.numeric(unique(diabetes_mellitus$value)))))
diabetes_mellitus$value[which(is.na((as.numeric(unique(diabetes_mellitus$value)))))]
diabetes_mellitus$value[which(is.na((as.numeric(diabetes_mellitus$value))))]
?dplyr::where
?dplyr:::where
dplyr:::where
dplyr:::where()
dplyr:::where
?subset
subset(diabetes_mellitus,is.na((as.numeric(diabetes_mellitus$value)))),select = measurement)
diabetes_mellitus$value[which(is.na((as.numeric(diabetes_mellitus$value))))] -> x
x
subset(diabetes_mellitus,x,select = measurement)
(is.na((as.numeric(diabetes_mellitus$value))) -> x
)
subset(diabetes_mellitus,x,select = measurement)
unique(subset(diabetes_mellitus,x,select = measurement))
#---- --- ---- --- ---- --- ---- --- ----#
# Diabetes mellitus and treatment
diabetes_mellitus <- merge_into_frame("Diabetes-Data",starts_with = "data-") |>
dplyr::rename(date = V1,
time = V2,
measurement = V3,
value = V4) |>
dplyr::mutate(value = as.numeric(value),
measurement = factor(measurement,
levels = c(33, 34, 35, 48, 57, 58, 59, 60, 61, 62, 63, 64, 65,
66, 67, 68, 69, 70, 71, 72),
labels = c(
"Regular insulin dose",
"NPH insulin dose",
"UltraLente insulin dose",
"Unspecified blood glucose measurement",
"Unspecified blood glucose measurement",
"Pre-breakfast blood glucose measurement",
"Post-breakfast blood glucose measurement",
"Pre-lunch blood glucose measurement",
"Post-lunch blood glucose measurement",
"Pre-supper blood glucose measurement",
"Post-supper blood glucose measurement",
"Pre-snack blood glucose measurement",
"Hypoglycemic symptoms",
"Typical meal ingestion",
"More-than-usual meal ingestion",
"Less-than-usual meal ingestion",
"Typical exercise activity",
"More-than-usual exercise activity",
"Less-than-usual exercise activity",
"Unspecified special event"
)
))
peek(diabetes_mellitus)
diabetes_mellitus$measurement
unique(diabetes_mellitus$measurement)
count_na(diabetes_mellitus)
#---- --- ---- --- ---- --- ---- --- ----#
# Diabetes mellitus and treatment
diabetes_mellitus <- merge_into_frame("Diabetes-Data",starts_with = "data-") |>
dplyr::rename(date = V1,
time = V2,
measurement = V3,
value = V4) |>
dplyr::mutate(value = as.numeric(value),
measurement = factor(measurement))
count_na(diabetes_mellitus)
View(file_row_counts)
participants <-  rep(paste0("Participant_", sprintf("%02d", 1:70)),file_row_counts$rows)
participants <-  rep(paste0("Participant_", sprintf("%02d", 1:70)),each = file_row_counts$rows)
sum(file_row_counts$rows)
paste0("Participant_", sprintf("%02d", 1:70))
paste0("P_", sprintf("%02d", 1:70))
data_rows <- file_row_counts$rows[1:70]
data_rows
View(file_row_counts)
participat_labels <- rep(participants, data_rows)
participat_labels <- rep(participants, each = data_rows)
r("participat_labrls")
r("participat_labels")
rm("participat_labels")
rm("participant")
rm("participants")
?rep
participat_labels <- rep(participants, length.out = data_rows)
participants <- paste0("P_", sprintf("%02d", 1:70))
participat_labels <- rep(participants, length.out = data_rows)
class(data_rows)
participat_labels <- rep(participants, times = data_rows)
participat_labels
unique(participat_labels)
participant_labels <- rep(participants, times = data_rows)
# Add a new column to diabetes_mellitus
diabetes_mellitus$participant <- participant_labels
View(file_row_counts)
count_na(diabetes_mellitus)
tf3 <- tempfile(tmpdir = "data",fileext = ".parquet")
write_dataset(diabetes_mellitus, tf3)
library(arrow)   # for creating, reading,
# writing parquet files
library(dplyr)   # for data wrangling
library(tidyr)   # for more data wrangling
library(here)    # for working with dir/files
library(readr)   # for reading csv files)
library(stringr) # for string manipulation
tf3 <- tempfile(tmpdir = "data",fileext = ".parquet")
write_dataset(diabetes_mellitus, tf3)
